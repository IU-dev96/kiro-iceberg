/**
 * Property-based tests for SparkleSystem
 * Uses fast-check for property-based testing
 */

import { describe, it } from 'vitest';
import * as fc from 'fast-check';
import { SparkleSystem } from './sparkles';
import { GhostCharacter } from './models';

describe('SparkleSystem', () => {
  /**
   * **Feature: sparkle-trail, Property 1: Movement triggers sparkle generation**
   * **Validates: Requirements 1.1**
   * 
   * For any game state where the character is moving horizontally, calling the sparkle 
   * system update should result in new sparkles being generated at the character's position
   */
  it('Property 1: Movement triggers sparkle generation', () => {
    fc.assert(
      fc.property(
        // Generate random character position and dimensions
        fc.record({
          x: fc.float({ min: Math.fround(0), max: Math.fround(800), noNaN: true }),
          y: fc.float({ min: Math.fround(0), max: Math.fround(600), noNaN: true }),
          width: fc.float({ min: Math.fround(20), max: Math.fround(50), noNaN: true }),
          height: fc.float({ min: Math.fround(30), max: Math.fround(60), noNaN: true }),
          deltaTime: fc.float({ min: Math.fround(0.016), max: Math.fround(0.1), noNaN: true }) // 16ms to 100ms
        }),
        ({ x, y, width, height, deltaTime }) => {
          // Skip invalid values
          if (!isFinite(x) || !isFinite(y) || !isFinite(width) || !isFinite(height) || !isFinite(deltaTime)) {
            return true;
          }

          // Create sparkle system and character
          const sparkleSystem = new SparkleSystem();
          const character = new GhostCharacter(x, y, width, height, 200, 800, 1);

          // Get initial particle count
          const initialCount = sparkleSystem.getParticles().length;

          // Update with movement (isMoving = true)
          sparkleSystem.update(character, deltaTime, true);

          // Get final particle count
          const finalCount = sparkleSystem.getParticles().length;

          // When moving, sparkles should be generated (count should increase or stay same if at max)
          // We expect at least some sparkles to be generated over time
          // For a single frame, we might not always generate (depends on rate), so we test over multiple frames
          let totalGenerated = finalCount - initialCount;

          // Run a few more frames to ensure generation happens
          for (let i = 0; i < 5; i++) {
            const beforeCount = sparkleSystem.getParticles().length;
            sparkleSystem.update(character, deltaTime, true);
            const afterCount = sparkleSystem.getParticles().length;
            totalGenerated += Math.max(0, afterCount - beforeCount);
          }

          // After multiple frames of movement, we should have generated sparkles
          return totalGenerated > 0;
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * **Feature: sparkle-trail, Property 2: Stationary character produces no sparkles**
   * **Validates: Requirements 1.2**
   * 
   * For any game state where the character is stationary (no directional input), 
   * calling the sparkle system update should not generate new sparkles
   */
  it('Property 2: Stationary character produces no sparkles', () => {
    fc.assert(
      fc.property(
        // Generate random character position and dimensions
        fc.record({
          x: fc.float({ min: Math.fround(0), max: Math.fround(800), noNaN: true }),
          y: fc.float({ min: Math.fround(0), max: Math.fround(600), noNaN: true }),
          width: fc.float({ min: Math.fround(20), max: Math.fround(50), noNaN: true }),
          height: fc.float({ min: Math.fround(30), max: Math.fround(60), noNaN: true }),
          deltaTime: fc.float({ min: Math.fround(0.016), max: Math.fround(0.1), noNaN: true }),
          numFrames: fc.integer({ min: 1, max: 10 })
        }),
        ({ x, y, width, height, deltaTime, numFrames }) => {
          // Create sparkle system and character
          const sparkleSystem = new SparkleSystem();
          const character = new GhostCharacter(x, y, width, height, 200, 800, 1);

          // Update multiple frames with no movement (isMoving = false)
          for (let i = 0; i < numFrames; i++) {
            sparkleSystem.update(character, deltaTime, false);
          }

          // No sparkles should be generated when stationary
          const particleCount = sparkleSystem.getParticles().length;
          return particleCount === 0;
        }
      ),
      { numRuns: 100 }
    );
  });
});

  /**
   * **Feature: sparkle-trail, Property 3: Sparkle colors are from palette**
   * **Validates: Requirements 1.3, 3.1**
   * 
   * For any sparkle generated by the system, its color should be a member of the predefined color palette
   */
  it('Property 3: Sparkle colors are from palette', () => {
    const COLOR_PALETTE = [
      '#FF6B9D', '#C44569', '#FFA07A', '#FFD700',
      '#87CEEB', '#9B59B6', '#3498DB', '#2ECC71'
    ];

    fc.assert(
      fc.property(
        fc.record({
          x: fc.float({ min: Math.fround(0), max: Math.fround(800), noNaN: true }),
          y: fc.float({ min: Math.fround(0), max: Math.fround(600), noNaN: true }),
          width: fc.float({ min: Math.fround(20), max: Math.fround(50), noNaN: true }),
          height: fc.float({ min: Math.fround(30), max: Math.fround(60), noNaN: true }),
          deltaTime: fc.float({ min: Math.fround(0.016), max: Math.fround(0.1), noNaN: true })
        }),
        ({ x, y, width, height, deltaTime }) => {
          if (!isFinite(x) || !isFinite(y) || !isFinite(width) || !isFinite(height) || !isFinite(deltaTime)) {
            return true;
          }

          const sparkleSystem = new SparkleSystem();
          const character = new GhostCharacter(x, y, width, height, 200, 800, 1);

          // Generate sparkles by moving for several frames
          for (let i = 0; i < 10; i++) {
            sparkleSystem.update(character, deltaTime, true);
          }

          const particles = sparkleSystem.getParticles();

          // All sparkles should have colors from the palette
          return particles.every(p => COLOR_PALETTE.includes(p.color));
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * **Feature: sparkle-trail, Property 4: Sparkles spawn within character bounds**
   * **Validates: Requirements 1.4**
   * 
   * For any sparkle generated by the system, its initial position should be within 
   * the character's bounding box (x, y, width, height)
   * 
   * Note: We test this by using a very small deltaTime to minimize drift, and allowing
   * for the maximum possible drift distance in our bounds check.
   */
  it('Property 4: Sparkles spawn within character bounds', () => {
    fc.assert(
      fc.property(
        fc.record({
          x: fc.float({ min: Math.fround(0), max: Math.fround(800), noNaN: true }),
          y: fc.float({ min: Math.fround(0), max: Math.fround(600), noNaN: true }),
          width: fc.float({ min: Math.fround(20), max: Math.fround(50), noNaN: true }),
          height: fc.float({ min: Math.fround(30), max: Math.fround(60), noNaN: true }),
          deltaTime: fc.float({ min: Math.fround(0.001), max: Math.fround(0.005), noNaN: true }) // Very small deltaTime
        }),
        ({ x, y, width, height, deltaTime }) => {
          if (!isFinite(x) || !isFinite(y) || !isFinite(width) || !isFinite(height) || !isFinite(deltaTime)) {
            return true;
          }

          const sparkleSystem = new SparkleSystem();
          const character = new GhostCharacter(x, y, width, height, 200, 800, 1);

          // Generate sparkles with a very small deltaTime to minimize drift
          sparkleSystem.update(character, deltaTime, true);

          const particles = sparkleSystem.getParticles();

          // Calculate maximum possible drift (max velocity * deltaTime)
          const maxDrift = 20 * deltaTime + 1; // 20 is max drift speed, +1 for safety margin

          // All sparkles should be within character bounds plus maximum drift
          return particles.every(p => 
            p.x >= x - maxDrift && p.x <= x + width + maxDrift &&
            p.y >= y - maxDrift && p.y <= y + height + maxDrift
          );
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * **Feature: sparkle-trail, Property 11: Sparkles have velocity assigned**
   * **Validates: Requirements 4.1**
   * 
   * For any sparkle generated by the system, it should have non-zero velocity components (vx and vy)
   */
  it('Property 11: Sparkles have velocity assigned', () => {
    fc.assert(
      fc.property(
        fc.record({
          x: fc.float({ min: Math.fround(0), max: Math.fround(800), noNaN: true }),
          y: fc.float({ min: Math.fround(0), max: Math.fround(600), noNaN: true }),
          width: fc.float({ min: Math.fround(20), max: Math.fround(50), noNaN: true }),
          height: fc.float({ min: Math.fround(30), max: Math.fround(60), noNaN: true }),
          deltaTime: fc.float({ min: Math.fround(0.05), max: Math.fround(0.1), noNaN: true })
        }),
        ({ x, y, width, height, deltaTime }) => {
          if (!isFinite(x) || !isFinite(y) || !isFinite(width) || !isFinite(height) || !isFinite(deltaTime)) {
            return true;
          }

          const sparkleSystem = new SparkleSystem();
          const character = new GhostCharacter(x, y, width, height, 200, 800, 1);

          // Generate sparkles
          sparkleSystem.update(character, deltaTime, true);

          const particles = sparkleSystem.getParticles();

          // All sparkles should have velocity (vx and vy should be defined)
          // Note: velocity can be zero by random chance, but both should be defined numbers
          return particles.every(p => 
            typeof p.vx === 'number' && isFinite(p.vx) &&
            typeof p.vy === 'number' && isFinite(p.vy)
          );
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * **Feature: sparkle-trail, Property 6: All sparkles have valid lifetime**
   * **Validates: Requirements 2.1**
   * 
   * For any sparkle in the system, it should have a lifetime value greater than 0 
   * and less than or equal to its maximum lifetime
   */
  it('Property 6: All sparkles have valid lifetime', () => {
    fc.assert(
      fc.property(
        fc.record({
          x: fc.float({ min: Math.fround(0), max: Math.fround(800), noNaN: true }),
          y: fc.float({ min: Math.fround(0), max: Math.fround(600), noNaN: true }),
          width: fc.float({ min: Math.fround(20), max: Math.fround(50), noNaN: true }),
          height: fc.float({ min: Math.fround(30), max: Math.fround(60), noNaN: true }),
          deltaTime: fc.float({ min: Math.fround(0.016), max: Math.fround(0.05), noNaN: true })
        }),
        ({ x, y, width, height, deltaTime }) => {
          if (!isFinite(x) || !isFinite(y) || !isFinite(width) || !isFinite(height) || !isFinite(deltaTime)) {
            return true;
          }

          const sparkleSystem = new SparkleSystem();
          const character = new GhostCharacter(x, y, width, height, 200, 800, 1);

          // Generate sparkles
          for (let i = 0; i < 5; i++) {
            sparkleSystem.update(character, deltaTime, true);
          }

          const particles = sparkleSystem.getParticles();

          // All sparkles should have valid lifetime (0 < life <= maxLife)
          return particles.every(p => 
            p.life > 0 && p.life <= p.maxLife && isFinite(p.life) && isFinite(p.maxLife)
          );
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * **Feature: sparkle-trail, Property 5: Consistent generation rate during movement**
   * **Validates: Requirements 1.5, 6.2**
   * 
   * For any continuous movement period, the number of sparkles generated should be 
   * proportional to the elapsed time multiplied by the generation rate (within reasonable tolerance)
   * 
   * Note: We test over a short time period to minimize particle expiration effects
   */
  it('Property 5: Consistent generation rate during movement', () => {
    fc.assert(
      fc.property(
        fc.record({
          x: fc.float({ min: Math.fround(100), max: Math.fround(700), noNaN: true }),
          y: fc.float({ min: Math.fround(100), max: Math.fround(500), noNaN: true }),
          width: fc.float({ min: Math.fround(20), max: Math.fround(50), noNaN: true }),
          height: fc.float({ min: Math.fround(30), max: Math.fround(60), noNaN: true }),
          deltaTime: fc.float({ min: Math.fround(0.016), max: Math.fround(0.033), noNaN: true }),
          numFrames: fc.integer({ min: 10, max: 20 }) // Shorter test to avoid expiration
        }),
        ({ x, y, width, height, deltaTime, numFrames }) => {
          if (!isFinite(x) || !isFinite(y) || !isFinite(width) || !isFinite(height) || !isFinite(deltaTime)) {
            return true;
          }

          const sparkleSystem = new SparkleSystem();
          const character = new GhostCharacter(x, y, width, height, 200, 800, 1);

          // Generate sparkles over multiple frames
          for (let i = 0; i < numFrames; i++) {
            sparkleSystem.update(character, deltaTime, true);
          }

          const totalTime = deltaTime * numFrames;
          const expectedCount = 20 * totalTime; // 20 particles per second
          const actualCount = sparkleSystem.getParticles().length;

          // Particles have 0.8s lifetime, so if totalTime < 0.8s, most should still be alive
          // Allow for generous tolerance due to discrete generation timing and some expiration
          const tolerance = Math.max(10, expectedCount * 0.5); // 50% tolerance or at least 10
          return Math.abs(actualCount - expectedCount) <= tolerance;
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * **Feature: sparkle-trail, Property 7: Opacity decreases over time**
   * **Validates: Requirements 2.2**
   * 
   * For any sparkle, advancing time should result in decreased opacity (life/maxLife ratio decreases)
   */
  it('Property 7: Opacity decreases over time', () => {
    fc.assert(
      fc.property(
        fc.record({
          x: fc.float({ min: Math.fround(100), max: Math.fround(700), noNaN: true }),
          y: fc.float({ min: Math.fround(100), max: Math.fround(500), noNaN: true }),
          width: fc.float({ min: Math.fround(20), max: Math.fround(50), noNaN: true }),
          height: fc.float({ min: Math.fround(30), max: Math.fround(60), noNaN: true }),
          deltaTime1: fc.float({ min: Math.fround(0.05), max: Math.fround(0.1), noNaN: true }),
          deltaTime2: fc.float({ min: Math.fround(0.01), max: Math.fround(0.05), noNaN: true })
        }),
        ({ x, y, width, height, deltaTime1, deltaTime2 }) => {
          if (!isFinite(x) || !isFinite(y) || !isFinite(width) || !isFinite(height) || 
              !isFinite(deltaTime1) || !isFinite(deltaTime2)) {
            return true;
          }

          const sparkleSystem = new SparkleSystem();
          const character = new GhostCharacter(x, y, width, height, 200, 800, 1);

          // Generate sparkles
          sparkleSystem.update(character, deltaTime1, true);

          const particlesBefore = sparkleSystem.getParticles();
          if (particlesBefore.length === 0) return true; // Skip if no particles generated

          // Record initial opacities
          const opacitiesBefore = particlesBefore.map(p => p.life / p.maxLife);

          // Advance time
          sparkleSystem.update(character, deltaTime2, false); // Not moving to avoid new particles

          const particlesAfter = sparkleSystem.getParticles();

          // Check that opacity decreased for particles that still exist
          // (some may have been removed if they expired)
          const minLength = Math.min(particlesBefore.length, particlesAfter.length);
          if (minLength === 0) return true;

          // Check the first few particles that should still exist
          for (let i = 0; i < Math.min(3, minLength); i++) {
            const opacityAfter = particlesAfter[i].life / particlesAfter[i].maxLife;
            if (opacityAfter >= opacitiesBefore[i]) {
              return false; // Opacity should have decreased
            }
          }

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * **Feature: sparkle-trail, Property 8: Expired sparkles are removed**
   * **Validates: Requirements 2.3, 5.4**
   * 
   * For any sparkle whose lifetime has expired (life <= 0), it should be removed 
   * from the active particle collection
   */
  it('Property 8: Expired sparkles are removed', () => {
    fc.assert(
      fc.property(
        fc.record({
          x: fc.float({ min: Math.fround(100), max: Math.fround(700), noNaN: true }),
          y: fc.float({ min: Math.fround(100), max: Math.fround(500), noNaN: true }),
          width: fc.float({ min: Math.fround(20), max: Math.fround(50), noNaN: true }),
          height: fc.float({ min: Math.fround(30), max: Math.fround(60), noNaN: true })
        }),
        ({ x, y, width, height }) => {
          if (!isFinite(x) || !isFinite(y) || !isFinite(width) || !isFinite(height)) {
            return true;
          }

          const sparkleSystem = new SparkleSystem();
          const character = new GhostCharacter(x, y, width, height, 200, 800, 1);

          // Generate sparkles
          sparkleSystem.update(character, 0.05, true);

          // Advance time well beyond particle lifetime (0.8s) to ensure expiration
          for (let i = 0; i < 20; i++) {
            sparkleSystem.update(character, 0.1, false); // 2 seconds total
          }

          const particles = sparkleSystem.getParticles();

          // All remaining particles should have positive life
          return particles.every(p => p.life > 0);
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * **Feature: sparkle-trail, Property 12: Position updates follow velocity**
   * **Validates: Requirements 4.2**
   * 
   * For any sparkle with known velocity, advancing time by deltaTime should change 
   * its position by approximately velocity * deltaTime
   */
  it('Property 12: Position updates follow velocity', () => {
    fc.assert(
      fc.property(
        fc.record({
          x: fc.float({ min: Math.fround(100), max: Math.fround(700), noNaN: true }),
          y: fc.float({ min: Math.fround(100), max: Math.fround(500), noNaN: true }),
          width: fc.float({ min: Math.fround(20), max: Math.fround(50), noNaN: true }),
          height: fc.float({ min: Math.fround(30), max: Math.fround(60), noNaN: true }),
          deltaTime: fc.float({ min: Math.fround(0.016), max: Math.fround(0.05), noNaN: true })
        }),
        ({ x, y, width, height, deltaTime }) => {
          if (!isFinite(x) || !isFinite(y) || !isFinite(width) || !isFinite(height) || !isFinite(deltaTime)) {
            return true;
          }

          const sparkleSystem = new SparkleSystem();
          const character = new GhostCharacter(x, y, width, height, 200, 800, 1);

          // Generate sparkles
          sparkleSystem.update(character, 0.05, true);

          const particlesBefore = sparkleSystem.getParticles();
          if (particlesBefore.length === 0) return true;

          // Record positions and velocities
          const snapshot = particlesBefore.map(p => ({
            x: p.x,
            y: p.y,
            vx: p.vx,
            vy: p.vy
          }));

          // Update without generating new particles
          sparkleSystem.update(character, deltaTime, false);

          const particlesAfter = sparkleSystem.getParticles();

          // Check position changes match velocity * deltaTime (with tolerance for floating point)
          const minLength = Math.min(snapshot.length, particlesAfter.length);
          for (let i = 0; i < minLength; i++) {
            const expectedX = snapshot[i].x + snapshot[i].vx * deltaTime;
            const expectedY = snapshot[i].y + snapshot[i].vy * deltaTime;
            const actualX = particlesAfter[i].x;
            const actualY = particlesAfter[i].y;

            const tolerance = 0.1; // Small tolerance for floating point errors
            if (Math.abs(actualX - expectedX) > tolerance || Math.abs(actualY - expectedY) > tolerance) {
              return false;
            }
          }

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * **Feature: sparkle-trail, Property 10: All sparkles are updated**
   * **Validates: Requirements 2.5**
   * 
   * For any collection of active sparkles, calling update should modify the state 
   * (position or lifetime) of all sparkles
   */
  it('Property 10: All sparkles are updated', () => {
    fc.assert(
      fc.property(
        fc.record({
          x: fc.float({ min: Math.fround(100), max: Math.fround(700), noNaN: true }),
          y: fc.float({ min: Math.fround(100), max: Math.fround(500), noNaN: true }),
          width: fc.float({ min: Math.fround(20), max: Math.fround(50), noNaN: true }),
          height: fc.float({ min: Math.fround(30), max: Math.fround(60), noNaN: true }),
          deltaTime: fc.float({ min: Math.fround(0.016), max: Math.fround(0.05), noNaN: true })
        }),
        ({ x, y, width, height, deltaTime }) => {
          if (!isFinite(x) || !isFinite(y) || !isFinite(width) || !isFinite(height) || !isFinite(deltaTime)) {
            return true;
          }

          const sparkleSystem = new SparkleSystem();
          const character = new GhostCharacter(x, y, width, height, 200, 800, 1);

          // Generate sparkles
          sparkleSystem.update(character, 0.05, true);

          const particlesBefore = sparkleSystem.getParticles();
          if (particlesBefore.length === 0) return true;

          // Record state before update
          const stateBefore = particlesBefore.map(p => ({
            x: p.x,
            y: p.y,
            life: p.life
          }));

          // Update
          sparkleSystem.update(character, deltaTime, false);

          const particlesAfter = sparkleSystem.getParticles();

          // All particles should have changed (either position or lifetime)
          const minLength = Math.min(stateBefore.length, particlesAfter.length);
          for (let i = 0; i < minLength; i++) {
            const posChanged = particlesAfter[i].x !== stateBefore[i].x || 
                              particlesAfter[i].y !== stateBefore[i].y;
            const lifeChanged = particlesAfter[i].life !== stateBefore[i].life;

            if (!posChanged && !lifeChanged) {
              return false; // At least one should have changed
            }
          }

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * **Feature: sparkle-trail, Property 13: Frame-rate independence**
   * **Validates: Requirements 5.3**
   * 
   * For any sparkle system state, updating with one large time step should produce 
   * similar results to updating with multiple smaller time steps that sum to the same duration
   */
  it('Property 13: Frame-rate independence', () => {
    fc.assert(
      fc.property(
        fc.record({
          x: fc.float({ min: Math.fround(100), max: Math.fround(700), noNaN: true }),
          y: fc.float({ min: Math.fround(100), max: Math.fround(500), noNaN: true }),
          width: fc.float({ min: Math.fround(20), max: Math.fround(50), noNaN: true }),
          height: fc.float({ min: Math.fround(30), max: Math.fround(60), noNaN: true }),
          totalTime: fc.float({ min: Math.fround(0.1), max: Math.fround(0.3), noNaN: true })
        }),
        ({ x, y, width, height, totalTime }) => {
          if (!isFinite(x) || !isFinite(y) || !isFinite(width) || !isFinite(height) || !isFinite(totalTime)) {
            return true;
          }

          const character = new GhostCharacter(x, y, width, height, 200, 800, 1);

          // Test 1: One large step
          const system1 = new SparkleSystem();
          system1.update(character, totalTime, true);
          const count1 = system1.getParticles().length;

          // Test 2: Multiple small steps
          const system2 = new SparkleSystem();
          const numSteps = 10;
          const smallStep = totalTime / numSteps;
          for (let i = 0; i < numSteps; i++) {
            system2.update(character, smallStep, true);
          }
          const count2 = system2.getParticles().length;

          // The particle counts should be similar (within reasonable tolerance)
          // Allow for some difference due to discrete generation timing
          const tolerance = Math.max(5, Math.ceil(count1 * 0.2)); // 20% tolerance or at least 5
          return Math.abs(count1 - count2) <= tolerance;
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * **Feature: sparkle-trail, Property 15: Maximum particle limit enforced**
   * **Validates: Requirements 6.3**
   * 
   * For any system state, the number of active sparkles should never exceed the 
   * configured maximum particle count
   */
  it('Property 15: Maximum particle limit enforced', () => {
    fc.assert(
      fc.property(
        fc.record({
          x: fc.float({ min: Math.fround(100), max: Math.fround(700), noNaN: true }),
          y: fc.float({ min: Math.fround(100), max: Math.fround(500), noNaN: true }),
          width: fc.float({ min: Math.fround(20), max: Math.fround(50), noNaN: true }),
          height: fc.float({ min: Math.fround(30), max: Math.fround(60), noNaN: true }),
          numFrames: fc.integer({ min: 50, max: 200 }) // Generate many particles
        }),
        ({ x, y, width, height, numFrames }) => {
          if (!isFinite(x) || !isFinite(y) || !isFinite(width) || !isFinite(height)) {
            return true;
          }

          const sparkleSystem = new SparkleSystem();
          const character = new GhostCharacter(x, y, width, height, 200, 800, 1);

          // Generate many sparkles to try to exceed the limit
          for (let i = 0; i < numFrames; i++) {
            sparkleSystem.update(character, 0.016, true);
            
            // Check that we never exceed the maximum (100 particles)
            const count = sparkleSystem.getParticles().length;
            if (count > 100) {
              return false;
            }
          }

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * **Feature: sparkle-trail, Property 16: Oldest sparkles removed at capacity**
   * **Validates: Requirements 6.4**
   * 
   * For any system at maximum capacity, generating a new sparkle should result in 
   * the oldest sparkle being removed
   */
  it('Property 16: Oldest sparkles removed at capacity', () => {
    fc.assert(
      fc.property(
        fc.record({
          x: fc.float({ min: Math.fround(100), max: Math.fround(700), noNaN: true }),
          y: fc.float({ min: Math.fround(100), max: Math.fround(500), noNaN: true }),
          width: fc.float({ min: Math.fround(20), max: Math.fround(50), noNaN: true }),
          height: fc.float({ min: Math.fround(30), max: Math.fround(60), noNaN: true })
        }),
        ({ x, y, width, height }) => {
          if (!isFinite(x) || !isFinite(y) || !isFinite(width) || !isFinite(height)) {
            return true;
          }

          const sparkleSystem = new SparkleSystem();
          const character = new GhostCharacter(x, y, width, height, 200, 800, 1);

          // Fill system to capacity (100 particles)
          for (let i = 0; i < 150; i++) {
            sparkleSystem.update(character, 0.016, true);
          }

          // System should be at or near capacity
          const particles = sparkleSystem.getParticles();
          if (particles.length < 90) return true; // Skip if not near capacity

          // Record the oldest particle's properties (first in array)
          const oldestLife = particles[0].life;

          // Generate more sparkles
          sparkleSystem.update(character, 0.05, true);

          const newParticles = sparkleSystem.getParticles();

          // The oldest particle should have been removed
          // Check that the first particle now has a different (higher) life value
          // or that the total count stayed at or below the limit
          return newParticles.length <= 100 && 
                 (newParticles.length === 0 || newParticles[0].life !== oldestLife);
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * **Feature: sparkle-trail, Property 9: Newer sparkles have higher opacity**
   * **Validates: Requirements 2.4**
   * 
   * For any two sparkles where one was created before the other, the newer sparkle 
   * should have higher opacity (life/maxLife ratio) than the older one
   */
  it('Property 9: Newer sparkles have higher opacity', () => {
    fc.assert(
      fc.property(
        fc.record({
          x: fc.float({ min: Math.fround(100), max: Math.fround(700), noNaN: true }),
          y: fc.float({ min: Math.fround(100), max: Math.fround(500), noNaN: true }),
          width: fc.float({ min: Math.fround(20), max: Math.fround(50), noNaN: true }),
          height: fc.float({ min: Math.fround(30), max: Math.fround(60), noNaN: true }),
          deltaTime: fc.float({ min: Math.fround(0.016), max: Math.fround(0.033), noNaN: true })
        }),
        ({ x, y, width, height, deltaTime }) => {
          if (!isFinite(x) || !isFinite(y) || !isFinite(width) || !isFinite(height) || !isFinite(deltaTime)) {
            return true;
          }

          const sparkleSystem = new SparkleSystem();
          const character = new GhostCharacter(x, y, width, height, 200, 800, 1);

          // Generate first batch of sparkles
          sparkleSystem.update(character, 0.05, true);

          // Wait a bit (particles age)
          sparkleSystem.update(character, deltaTime, false);

          // Generate second batch of sparkles
          sparkleSystem.update(character, 0.05, true);

          const particles = sparkleSystem.getParticles();
          if (particles.length < 2) return true; // Need at least 2 particles

          // Older particles are at the beginning of the array
          // Newer particles are at the end
          const oldParticle = particles[0];
          const newParticle = particles[particles.length - 1];

          const oldOpacity = oldParticle.life / oldParticle.maxLife;
          const newOpacity = newParticle.life / newParticle.maxLife;

          // Newer particle should have higher opacity
          return newOpacity > oldOpacity;
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * **Feature: sparkle-trail, Property 14: Generation rate within bounds**
   * **Validates: Requirements 6.1**
   * 
   * For any extended movement period, the average sparkle generation rate should be 
   * between 10 and 30 particles per second
   */
  it('Property 14: Generation rate within bounds', () => {
    fc.assert(
      fc.property(
        fc.record({
          x: fc.float({ min: Math.fround(100), max: Math.fround(700), noNaN: true }),
          y: fc.float({ min: Math.fround(100), max: Math.fround(500), noNaN: true }),
          width: fc.float({ min: Math.fround(20), max: Math.fround(50), noNaN: true }),
          height: fc.float({ min: Math.fround(30), max: Math.fround(60), noNaN: true }),
          testDuration: fc.float({ min: Math.fround(0.5), max: Math.fround(1.0), noNaN: true }) // Test for 0.5-1 second
        }),
        ({ x, y, width, height, testDuration }) => {
          if (!isFinite(x) || !isFinite(y) || !isFinite(width) || !isFinite(height) || !isFinite(testDuration)) {
            return true;
          }

          const sparkleSystem = new SparkleSystem();
          const character = new GhostCharacter(x, y, width, height, 200, 800, 1);

          // Simulate movement for the test duration
          const deltaTime = 0.016; // 60 FPS
          const numFrames = Math.ceil(testDuration / deltaTime);
          
          for (let i = 0; i < numFrames; i++) {
            sparkleSystem.update(character, deltaTime, true);
          }

          const particleCount = sparkleSystem.getParticles().length;
          const actualRate = particleCount / testDuration;

          // Rate should be between 10 and 30 particles per second
          // Allow some tolerance for particle expiration and discrete timing
          const minRate = 8; // Slightly below 10 to account for expiration
          const maxRate = 32; // Slightly above 30 for tolerance
          
          return actualRate >= minRate && actualRate <= maxRate;
        }
      ),
      { numRuns: 100 }
    );
  });
